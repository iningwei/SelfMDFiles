质数(prime number)又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其它因数。反之称为合数。
PS:小于等于1的数既不是质数也不是合数。


判断质数的算法实现：
解法一：暴力。由素数的定义可以遍历从2 ~ n-1的数，判断它们是否可以整除n。但是这样时间复杂度就到达了O(n)，通常判断素数只会作为程序的一部分，所以这样的时间复杂度还是有点高。

解法二：开根号。如果在2 ~ n-1中存在n的约数，不妨设为k，即n % k == 0，那么由 k * （n / k）== n可知，n/k也是n的一个约数，且k与n/k中一定满足其中一个小于等于 $\sqrt{n}$，一个大于等于$\sqrt{n}$。这样我们只要判断2 ~ $\sqrt{n}$之间的整数就好了，时间复杂度为 O($\sqrt{n}$)。
代码如下：
```c
bool isPrime(int n){
	if(n <= 1){
		return false;	//特判 
	}
	int sqr = (int) sqrt(1.0 * n);	//根号n,这个1.0要乘，（int）也要加 
	for(int i=2;i <= sqr;++i){
		if(n % i == 0){	//注意是取余，而不是除法
			return false;
		}
	}
	return true;	//否则，就是true 
}
```

## 优化版
判断能否整除2之后，就可以无需判断其它偶数了，只需要判断3到$\sqrt{n}$之间的奇数，时间复杂度为O($\sqrt{n}/2$)

## 尊享版
质数分布的规律，大于等于5的质数一定和6的倍数相邻。
证明：令x≥1，将大于等于5的自然数表示如下：
··· 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ···
可以看到，不和6的倍数相邻的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，
再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。因此在5到$\sqrt{n}$中每6个数只判断2个，时间复杂度O($\sqrt{n}$/3)。
 
